{"version":3,"file":"cacccc8c4ba360fcff72.js","sources":["webpack:///./assets/js/webGL.js"],"sourcesContent":["/* eslint-disable */\n'use strict';\n\nconst canvas = document.getElementsByTagName('canvas')[0];\ncanvas.width = canvas.clientWidth;\ncanvas.height = canvas.clientHeight;\n\nlet config = {\n  SIM_RESOLUTION: 128,\n  DYE_RESOLUTION: 512,\n  DENSITY_DISSIPATION: 0.97,\n  VELOCITY_DISSIPATION: 0.98,\n  PRESSURE_DISSIPATION: 0.8,\n  PRESSURE_ITERATIONS: 20,\n  CURL: 30,\n  SPLAT_RADIUS: 0.5,\n  SHADING: true,\n  COLORFUL: true,\n  PAUSED: false,\n  BACK_COLOR: { r: 255, g: 255, b: 255 },\n  TRANSPARENT: false,\n  BLOOM: true,\n  BLOOM_ITERATIONS: 8,\n  BLOOM_RESOLUTION: 256,\n  BLOOM_INTENSITY: 0.8,\n  BLOOM_THRESHOLD: 0.6,\n  BLOOM_SOFT_KNEE: 0.7\n}\n\nfunction pointerPrototype () {\n  this.id = -1;\n  this.x = 0;\n  this.y = 0;\n  this.dx = 0;\n  this.dy = 0;\n  this.down = false;\n  this.moved = false;\n  this.color = [30, 0, 300];\n}\n\nlet pointers = [];\nlet splatStack = [];\nlet bloomFramebuffers = [];\npointers.push(new pointerPrototype());\n\nconst { gl, ext } = getWebGLContext(canvas);\n\nif (isMobile())\n  config.SHADING = false;\nif (!ext.supportLinearFiltering)\n{\n  config.SHADING = false;\n  config.BLOOM = false;\n}\n\nfunction getWebGLContext (canvas) {\n  const params = { alpha: true, depth: false, stencil: false, antialias: false, preserveDrawingBuffer: false };\n\n  let gl = canvas.getContext('webgl2', params);\n  const isWebGL2 = !!gl;\n  if (!isWebGL2)\n    gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);\n\n  let halfFloat;\n  let supportLinearFiltering;\n  if (isWebGL2) {\n    gl.getExtension('EXT_color_buffer_float');\n    supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n  } else {\n    halfFloat = gl.getExtension('OES_texture_half_float');\n    supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');\n  }\n\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n  const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;\n  let formatRGBA;\n  let formatRG;\n  let formatR;\n\n  if (isWebGL2)\n  {\n    formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n    formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n    formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n  }\n  else\n  {\n    formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n  }\n\n  return {\n    gl,\n    ext: {\n      formatRGBA,\n      formatRG,\n      formatR,\n      halfFloatTexType,\n      supportLinearFiltering\n    }\n  };\n}\n\nfunction getSupportedFormat (gl, internalFormat, format, type)\n{\n  if (!supportRenderTextureFormat(gl, internalFormat, format, type))\n  {\n    switch (internalFormat)\n    {\n      case gl.R16F:\n        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n      case gl.RG16F:\n        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n      default:\n        return null;\n    }\n  }\n\n  return {\n    internalFormat,\n    format\n  }\n}\n\nfunction supportRenderTextureFormat (gl, internalFormat, format, type) {\n  let texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n\n  let fbo = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status != gl.FRAMEBUFFER_COMPLETE)\n    return false;\n  return true;\n}\n\nfunction captureScreenshot () {\n  colorProgram.bind();\n  gl.uniform4f(colorProgram.uniforms.color, 0, 0, 0, 1);\n  blit(density.write.fbo);\n\n  render(density.write.fbo);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, density.write.fbo);\n\n  let length = dyeWidth * dyeHeight * 4;\n  let pixels = new Float32Array(length);\n  gl.readPixels(0, 0, dyeWidth, dyeHeight, gl.RGBA, gl.FLOAT, pixels);\n\n  let newPixels = new Uint8Array(length);\n\n  let id = 0;\n  for (let i = dyeHeight - 1; i >= 0; i--) {\n    for (let j = 0; j < dyeWidth; j++) {\n      let nid = i * dyeWidth * 4 + j * 4;\n      newPixels[nid + 0] = clamp01(pixels[id + 0]) * 255;\n      newPixels[nid + 1] = clamp01(pixels[id + 1]) * 255;\n      newPixels[nid + 2] = clamp01(pixels[id + 2]) * 255;\n      newPixels[nid + 3] = clamp01(pixels[id + 3]) * 255;\n      id += 4;\n    }\n  }\n\n  let captureCanvas = document.createElement('canvas');\n  let ctx = captureCanvas.getContext('2d');\n  captureCanvas.width = dyeWidth;\n  captureCanvas.height = dyeHeight;\n\n  let imageData = ctx.createImageData(dyeWidth, dyeHeight);\n  imageData.data.set(newPixels);\n  ctx.putImageData(imageData, 0, 0);\n  let datauri = captureCanvas.toDataURL();\n\n  downloadURI(\"fluid.png\", datauri);\n\n  URL.revokeObjectURL(datauri);\n}\n\nfunction clamp01 (input) {\n  return Math.min(Math.max(input, 0), 1);\n}\n\nfunction downloadURI (filename, uri) {\n  let link = document.createElement(\"a\");\n  link.download = filename;\n  link.href = uri;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n}\n\nfunction isMobile () {\n  return /Mobi|Android/i.test(navigator.userAgent);\n}\n\nclass GLProgram {\n  constructor (vertexShader, fragmentShader) {\n    this.uniforms = {};\n    this.program = gl.createProgram();\n\n    gl.attachShader(this.program, vertexShader);\n    gl.attachShader(this.program, fragmentShader);\n    gl.linkProgram(this.program);\n\n    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))\n      throw gl.getProgramInfoLog(this.program);\n\n    const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < uniformCount; i++) {\n      const uniformName = gl.getActiveUniform(this.program, i).name;\n      this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n    }\n  }\n\n  bind () {\n    gl.useProgram(this.program);\n  }\n}\n\nfunction compileShader (type, source) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n    throw gl.getShaderInfoLog(shader);\n\n  return shader;\n};\n\nconst baseVertexShader = compileShader(gl.VERTEX_SHADER, `\n    precision highp float;\n\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform vec2 texelSize;\n\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n`);\n\nconst clearShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float value;\n\n    void main () {\n        gl_FragColor = value * texture2D(uTexture, vUv);\n    }\n`);\n\nconst colorShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n\n    uniform vec4 color;\n\n    void main () {\n        gl_FragColor = color;\n    }\n`);\n\nconst backgroundShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float aspectRatio;\n\n    #define SCALE 25.0\n\n    void main () {\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\n        float v = mod(uv.x + uv.y, 2.0);\n        v = v * 0.1 + 0.8;\n        gl_FragColor = vec4(vec3(v), 1.0);\n    }\n`);\n\nconst displayShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n`);\n\nconst displayBloomShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n\n    void main () {\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 800.0;\n        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));\n        C += bloom;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n`);\n\nconst displayShadingShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform vec2 texelSize;\n\n    void main () {\n        vec3 L = texture2D(uTexture, vL).rgb;\n        vec3 R = texture2D(uTexture, vR).rgb;\n        vec3 T = texture2D(uTexture, vT).rgb;\n        vec3 B = texture2D(uTexture, vB).rgb;\n        vec3 C = texture2D(uTexture, vUv).rgb;\n\n        float dx = length(R) - length(L);\n        float dy = length(T) - length(B);\n\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        C.rgb *= diffuse;\n\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n`);\n\nconst displayBloomShadingShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n    uniform vec2 texelSize;\n\n    void main () {\n        vec3 L = texture2D(uTexture, vL).rgb;\n        vec3 R = texture2D(uTexture, vR).rgb;\n        vec3 T = texture2D(uTexture, vT).rgb;\n        vec3 B = texture2D(uTexture, vB).rgb;\n        vec3 C = texture2D(uTexture, vUv).rgb;\n\n        float dx = length(R) - length(L);\n        float dy = length(T) - length(B);\n\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        C *= diffuse;\n\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 800.0;\n        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));\n        C += bloom;\n\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n`);\n\nconst bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform vec3 curve;\n    uniform float threshold;\n\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n        float br = max(c.r, max(c.g, c.b));\n        float rq = clamp(br - curve.x, 0.0, curve.y);\n        rq = curve.z * rq * rq;\n        c *= max(rq, br - threshold) / max(br, 0.0001);\n        gl_FragColor = vec4(c, 0.0);\n    }\n`);\n\nconst bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum;\n    }\n`);\n\nconst bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform float intensity;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum * intensity;\n    }\n`);\n\nconst splatShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTarget;\n    uniform float aspectRatio;\n    uniform vec3 color;\n    uniform vec2 point;\n    uniform float radius;\n\n    void main () {\n        vec2 p = vUv - point.xy;\n        p.x *= aspectRatio;\n        vec3 splat = exp(-dot(p, p) / radius) * color;\n        vec3 base = texture2D(uTarget, vUv).xyz;\n        gl_FragColor = vec4(base + splat, 1.0);\n    }\n`);\n\nconst advectionManualFilteringShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform vec2 dyeTexelSize;\n    uniform float dt;\n    uniform float dissipation;\n\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n        vec2 st = uv / tsize - 0.5;\n\n        vec2 iuv = floor(st);\n        vec2 fuv = fract(st);\n\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    }\n\n    void main () {\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n        gl_FragColor = dissipation * bilerp(uSource, coord, dyeTexelSize);\n        gl_FragColor.a = 1.0;\n    }\n`);\n\nconst advectionShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform float dt;\n    uniform float dissipation;\n\n    void main () {\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n        gl_FragColor = dissipation * texture2D(uSource, coord);\n        gl_FragColor.a = 1.0;\n    }\n`);\n\nconst divergenceShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).x;\n        float R = texture2D(uVelocity, vR).x;\n        float T = texture2D(uVelocity, vT).y;\n        float B = texture2D(uVelocity, vB).y;\n\n        vec2 C = texture2D(uVelocity, vUv).xy;\n        if (vL.x < 0.0) { L = -C.x; }\n        if (vR.x > 1.0) { R = -C.x; }\n        if (vT.y > 1.0) { T = -C.y; }\n        if (vB.y < 0.0) { B = -C.y; }\n\n        float div = 0.5 * (R - L + T - B);\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n    }\n`);\n\nconst curlShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).y;\n        float R = texture2D(uVelocity, vR).y;\n        float T = texture2D(uVelocity, vT).x;\n        float B = texture2D(uVelocity, vB).x;\n        float vorticity = R - L - T + B;\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n    }\n`);\n\nconst vorticityShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uCurl;\n    uniform float curl;\n    uniform float dt;\n\n    void main () {\n        float L = texture2D(uCurl, vL).x;\n        float R = texture2D(uCurl, vR).x;\n        float T = texture2D(uCurl, vT).x;\n        float B = texture2D(uCurl, vB).x;\n        float C = texture2D(uCurl, vUv).x;\n\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n        force /= length(force) + 0.0001;\n        force *= curl * C;\n        force.y *= -1.0;\n\n        vec2 vel = texture2D(uVelocity, vUv).xy;\n        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n    }\n`);\n\nconst pressureShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uDivergence;\n\n    vec2 boundary (vec2 uv) {\n        return uv;\n        // uncomment if you use wrap or repeat texture mode\n        // uv = min(max(uv, 0.0), 1.0);\n        // return uv;\n    }\n\n    void main () {\n        float L = texture2D(uPressure, boundary(vL)).x;\n        float R = texture2D(uPressure, boundary(vR)).x;\n        float T = texture2D(uPressure, boundary(vT)).x;\n        float B = texture2D(uPressure, boundary(vB)).x;\n        float C = texture2D(uPressure, vUv).x;\n        float divergence = texture2D(uDivergence, vUv).x;\n        float pressure = (L + R + B + T - divergence) * 0.25;\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n    }\n`);\n\nconst gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uVelocity;\n\n    vec2 boundary (vec2 uv) {\n        return uv;\n        // uv = min(max(uv, 0.0), 1.0);\n        // return uv;\n    }\n\n    void main () {\n        float L = texture2D(uPressure, boundary(vL)).x;\n        float R = texture2D(uPressure, boundary(vR)).x;\n        float T = texture2D(uPressure, boundary(vT)).x;\n        float B = texture2D(uPressure, boundary(vB)).x;\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity.xy -= vec2(R - L, T - B);\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n`);\n\nconst blit = (() => {\n  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(0);\n\n  return (destination) => {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n  }\n})();\n\nlet simWidth;\nlet simHeight;\nlet dyeWidth;\nlet dyeHeight;\nlet density;\nlet velocity;\nlet divergence;\nlet curl;\nlet pressure;\nlet bloom;\n\nlet ditheringTexture = createTextureAsync();\n\nconst clearProgram               = new GLProgram(baseVertexShader, clearShader);\nconst colorProgram               = new GLProgram(baseVertexShader, colorShader);\nconst backgroundProgram          = new GLProgram(baseVertexShader, backgroundShader);\nconst displayProgram             = new GLProgram(baseVertexShader, displayShader);\nconst displayBloomProgram        = new GLProgram(baseVertexShader, displayBloomShader);\nconst displayShadingProgram      = new GLProgram(baseVertexShader, displayShadingShader);\nconst displayBloomShadingProgram = new GLProgram(baseVertexShader, displayBloomShadingShader);\nconst bloomPrefilterProgram      = new GLProgram(baseVertexShader, bloomPrefilterShader);\nconst bloomBlurProgram           = new GLProgram(baseVertexShader, bloomBlurShader);\nconst bloomFinalProgram          = new GLProgram(baseVertexShader, bloomFinalShader);\nconst splatProgram               = new GLProgram(baseVertexShader, splatShader);\nconst advectionProgram           = new GLProgram(baseVertexShader, ext.supportLinearFiltering ? advectionShader : advectionManualFilteringShader);\nconst divergenceProgram          = new GLProgram(baseVertexShader, divergenceShader);\nconst curlProgram                = new GLProgram(baseVertexShader, curlShader);\nconst vorticityProgram           = new GLProgram(baseVertexShader, vorticityShader);\nconst pressureProgram            = new GLProgram(baseVertexShader, pressureShader);\nconst gradienSubtractProgram     = new GLProgram(baseVertexShader, gradientSubtractShader);\n\nfunction initFramebuffers () {\n  let simRes = getResolution(config.SIM_RESOLUTION);\n  let dyeRes = getResolution(config.DYE_RESOLUTION);\n\n  simWidth  = simRes.width;\n  simHeight = simRes.height;\n  dyeWidth  = dyeRes.width;\n  dyeHeight = dyeRes.height;\n\n  const texType = ext.halfFloatTexType;\n  const rgba    = ext.formatRGBA;\n  const rg      = ext.formatRG;\n  const r       = ext.formatR;\n  const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n\n  if (density == null)\n    density = createDoubleFBO(dyeWidth, dyeHeight, rgba.internalFormat, rgba.format, texType, filtering);\n  else\n    density = resizeDoubleFBO(density, dyeWidth, dyeHeight, rgba.internalFormat, rgba.format, texType, filtering);\n\n  if (velocity == null)\n    velocity = createDoubleFBO(simWidth, simHeight, rg.internalFormat, rg.format, texType, filtering);\n  else\n    velocity = resizeDoubleFBO(velocity, simWidth, simHeight, rg.internalFormat, rg.format, texType, filtering);\n\n  divergence = createFBO      (simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);\n  curl       = createFBO      (simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);\n  pressure   = createDoubleFBO(simWidth, simHeight, r.internalFormat, r.format, texType, gl.NEAREST);\n\n  initBloomFramebuffers();\n}\n\nfunction initBloomFramebuffers () {\n  let res = getResolution(config.BLOOM_RESOLUTION);\n\n  const texType = ext.halfFloatTexType;\n  const rgba = ext.formatRGBA;\n  const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n\n  bloom = createFBO(res.width, res.height, rgba.internalFormat, rgba.format, texType, filtering);\n\n  bloomFramebuffers.length = 0;\n  for (let i = 0; i < config.BLOOM_ITERATIONS; i++)\n  {\n    let width = res.width >> (i + 1);\n    let height = res.height >> (i + 1);\n\n    if (width < 2 || height < 2) break;\n\n    let fbo = createFBO(width, height, rgba.internalFormat, rgba.format, texType, filtering);\n    bloomFramebuffers.push(fbo);\n  }\n}\n\nfunction createFBO (w, h, internalFormat, format, type, param) {\n  gl.activeTexture(gl.TEXTURE0);\n  let texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n\n  let fbo = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  gl.viewport(0, 0, w, h);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  return {\n    texture,\n    fbo,\n    width: w,\n    height: h,\n    attach (id) {\n      gl.activeTexture(gl.TEXTURE0 + id);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      return id;\n    }\n  };\n}\n\nfunction createDoubleFBO (w, h, internalFormat, format, type, param) {\n  let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n  let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n\n  return {\n    get read () {\n      return fbo1;\n    },\n    set read (value) {\n      fbo1 = value;\n    },\n    get write () {\n      return fbo2;\n    },\n    set write (value) {\n      fbo2 = value;\n    },\n    swap () {\n      let temp = fbo1;\n      fbo1 = fbo2;\n      fbo2 = temp;\n    }\n  }\n}\n\nfunction resizeFBO (target, w, h, internalFormat, format, type, param) {\n  let newFBO = createFBO(w, h, internalFormat, format, type, param);\n  clearProgram.bind();\n  gl.uniform1i(clearProgram.uniforms.uTexture, target.attach(0));\n  gl.uniform1f(clearProgram.uniforms.value, 1);\n  blit(newFBO.fbo);\n  return newFBO;\n}\n\nfunction resizeDoubleFBO (target, w, h, internalFormat, format, type, param) {\n  target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n  target.write = createFBO(w, h, internalFormat, format, type, param);\n  return target;\n}\n\nfunction createTextureAsync () {\n  let texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));\n\n  let obj = {\n    texture,\n    width: 1,\n    height: 1,\n    attach (id) {\n      gl.activeTexture(gl.TEXTURE0 + id);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      return id;\n    }\n  };\n\n  let image = new Image();\n  image.onload = () => {\n    obj.width = image.width;\n    obj.height = image.height;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n  };\n  image.src = 'https://file.calibur.tv/LDR_RGB1_0.png';\n  image.crossOrigin = 'Anonymous';\n\n  return obj;\n}\n\ninitFramebuffers();\nmultipleSplats(parseInt(Math.random() * 20) + 5);\n\nlet lastColorChangeTime = Date.now();\n\nupdate();\n\nfunction update () {\n  resizeCanvas();\n  input();\n  if (!config.PAUSED)\n    step(0.016);\n  render(null);\n  requestAnimationFrame(update);\n}\n\nfunction input () {\n  if (splatStack.length > 0)\n    multipleSplats(splatStack.pop());\n\n  for (let i = 0; i < pointers.length; i++) {\n    const p = pointers[i];\n    if (p.moved) {\n      splat(p.x, p.y, p.dx, p.dy, p.color);\n      p.moved = false;\n    }\n  }\n\n  if (!config.COLORFUL)\n    return;\n\n  if (lastColorChangeTime + 100 < Date.now())\n  {\n    lastColorChangeTime = Date.now();\n    for (let i = 0; i < pointers.length; i++) {\n      const p = pointers[i];\n      p.color = generateColor();\n    }\n  }\n}\n\nfunction step (dt) {\n  gl.disable(gl.BLEND);\n  gl.viewport(0, 0, simWidth, simHeight);\n\n  curlProgram.bind();\n  gl.uniform2f(curlProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n  blit(curl.fbo);\n\n  vorticityProgram.bind();\n  gl.uniform2f(vorticityProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n  gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n  gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n  gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n  blit(velocity.write.fbo);\n  velocity.swap();\n\n  divergenceProgram.bind();\n  gl.uniform2f(divergenceProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n  blit(divergence.fbo);\n\n  clearProgram.bind();\n  gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n  gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE_DISSIPATION);\n  blit(pressure.write.fbo);\n  pressure.swap();\n\n  pressureProgram.bind();\n  gl.uniform2f(pressureProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n  for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n    gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n    blit(pressure.write.fbo);\n    pressure.swap();\n  }\n\n  gradienSubtractProgram.bind();\n  gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n  gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n  blit(velocity.write.fbo);\n  velocity.swap();\n\n  advectionProgram.bind();\n  gl.uniform2f(advectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  if (!ext.supportLinearFiltering)\n    gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / simWidth, 1.0 / simHeight);\n  let velocityId = velocity.read.attach(0);\n  gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n  gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n  gl.uniform1f(advectionProgram.uniforms.dt, dt);\n  gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n  blit(velocity.write.fbo);\n  velocity.swap();\n\n  gl.viewport(0, 0, dyeWidth, dyeHeight);\n\n  if (!ext.supportLinearFiltering)\n    gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / dyeWidth, 1.0 / dyeHeight);\n  gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n  gl.uniform1i(advectionProgram.uniforms.uSource, density.read.attach(1));\n  gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n  blit(density.write.fbo);\n  density.swap();\n}\n\nfunction render (target) {\n  if (config.BLOOM)\n    applyBloom(density.read, bloom);\n\n  if (target == null || !config.TRANSPARENT) {\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND);\n  }\n  else {\n    gl.disable(gl.BLEND);\n  }\n\n  let width  = target == null ? gl.drawingBufferWidth : dyeWidth;\n  let height = target == null ? gl.drawingBufferHeight : dyeHeight;\n\n  gl.viewport(0, 0, width, height);\n\n  if (!config.TRANSPARENT) {\n    colorProgram.bind();\n    let bc = config.BACK_COLOR;\n    gl.uniform4f(colorProgram.uniforms.color, bc.r / 255, bc.g / 255, bc.b / 255, 1);\n    blit(target);\n  }\n\n  if (target == null && config.TRANSPARENT) {\n    backgroundProgram.bind();\n    gl.uniform1f(backgroundProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    blit(null);\n  }\n\n  if (config.SHADING) {\n    let program = config.BLOOM ? displayBloomShadingProgram : displayShadingProgram;\n    program.bind();\n    gl.uniform2f(program.uniforms.texelSize, 1.0 / width, 1.0 / height);\n    gl.uniform1i(program.uniforms.uTexture, density.read.attach(0));\n    if (config.BLOOM) {\n      gl.uniform1i(program.uniforms.uBloom, bloom.attach(1));\n      gl.uniform1i(program.uniforms.uDithering, ditheringTexture.attach(2));\n      let scale = getTextureScale(ditheringTexture, width, height);\n      gl.uniform2f(program.uniforms.ditherScale, scale.x, scale.y);\n    }\n  }\n  else {\n    let program = config.BLOOM ? displayBloomProgram : displayProgram;\n    program.bind();\n    gl.uniform1i(program.uniforms.uTexture, density.read.attach(0));\n    if (config.BLOOM) {\n      gl.uniform1i(program.uniforms.uBloom, bloom.attach(1));\n      gl.uniform1i(program.uniforms.uDithering, ditheringTexture.attach(2));\n      let scale = getTextureScale(ditheringTexture, width, height);\n      gl.uniform2f(program.uniforms.ditherScale, scale.x, scale.y);\n    }\n  }\n\n  blit(target);\n}\n\nfunction applyBloom (source, destination) {\n  if (bloomFramebuffers.length < 2)\n    return;\n\n  let last = destination;\n\n  gl.disable(gl.BLEND);\n  bloomPrefilterProgram.bind();\n  let knee = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 0.0001;\n  let curve0 = config.BLOOM_THRESHOLD - knee;\n  let curve1 = knee * 2;\n  let curve2 = 0.25 / knee;\n  gl.uniform3f(bloomPrefilterProgram.uniforms.curve, curve0, curve1, curve2);\n  gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD);\n  gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, source.attach(0));\n  gl.viewport(0, 0, last.width, last.height);\n  blit(last.fbo);\n\n  bloomBlurProgram.bind();\n  for (let i = 0; i < bloomFramebuffers.length; i++) {\n    let dest = bloomFramebuffers[i];\n    gl.uniform2f(bloomBlurProgram.uniforms.texelSize, 1.0 / last.width, 1.0 / last.height);\n    gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n    gl.viewport(0, 0, dest.width, dest.height);\n    blit(dest.fbo);\n    last = dest;\n  }\n\n  gl.blendFunc(gl.ONE, gl.ONE);\n  gl.enable(gl.BLEND);\n\n  for (let i = bloomFramebuffers.length - 2; i >= 0; i--) {\n    let baseTex = bloomFramebuffers[i];\n    gl.uniform2f(bloomBlurProgram.uniforms.texelSize, 1.0 / last.width, 1.0 / last.height);\n    gl.uniform1i(bloomBlurProgram.uniforms.uTexture, last.attach(0));\n    gl.viewport(0, 0, baseTex.width, baseTex.height);\n    blit(baseTex.fbo);\n    last = baseTex;\n  }\n\n  gl.disable(gl.BLEND);\n  bloomFinalProgram.bind();\n  gl.uniform2f(bloomFinalProgram.uniforms.texelSize, 1.0 / last.width, 1.0 / last.height);\n  gl.uniform1i(bloomFinalProgram.uniforms.uTexture, last.attach(0));\n  gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY);\n  gl.viewport(0, 0, destination.width, destination.height);\n  blit(destination.fbo);\n}\n\nfunction splat (x, y, dx, dy, color) {\n  gl.viewport(0, 0, simWidth, simHeight);\n  splatProgram.bind();\n  gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n  gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n  gl.uniform2f(splatProgram.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);\n  gl.uniform3f(splatProgram.uniforms.color, dx, -dy, 1.0);\n  gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n  blit(velocity.write.fbo);\n  velocity.swap();\n\n  gl.viewport(0, 0, dyeWidth, dyeHeight);\n  gl.uniform1i(splatProgram.uniforms.uTarget, density.read.attach(0));\n  gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n  blit(density.write.fbo);\n  density.swap();\n}\n\nfunction multipleSplats (amount) {\n  for (let i = 0; i < amount; i++) {\n    const color = generateColor();\n    color.r *= 10.0;\n    color.g *= 10.0;\n    color.b *= 10.0;\n    const x = canvas.width * Math.random();\n    const y = canvas.height * Math.random();\n    const dx = 1000 * (Math.random() - 0.5);\n    const dy = 1000 * (Math.random() - 0.5);\n    splat(x, y, dx, dy, color);\n  }\n}\n\nfunction resizeCanvas () {\n  if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight) {\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    initFramebuffers();\n  }\n}\n\ncanvas.addEventListener('mousemove', e => {\n  pointers[0].moved = pointers[0].down;\n  pointers[0].dx = (e.offsetX - pointers[0].x) * 5.0;\n  pointers[0].dy = (e.offsetY - pointers[0].y) * 5.0;\n  pointers[0].x = e.offsetX;\n  pointers[0].y = e.offsetY;\n});\n\ncanvas.addEventListener('touchmove', e => {\n  e.preventDefault();\n  const touches = e.targetTouches;\n  for (let i = 0; i < touches.length; i++) {\n    let pointer = pointers[i];\n    pointer.moved = pointer.down;\n    pointer.dx = (touches[i].pageX - pointer.x) * 8.0;\n    pointer.dy = (touches[i].pageY - pointer.y) * 8.0;\n    pointer.x = touches[i].pageX;\n    pointer.y = touches[i].pageY;\n  }\n}, false);\n\ncanvas.addEventListener('mousedown', () => {\n  pointers[0].down = true;\n  pointers[0].color = generateColor();\n});\n\ncanvas.addEventListener('touchstart', e => {\n  e.preventDefault();\n  const touches = e.targetTouches;\n  for (let i = 0; i < touches.length; i++) {\n    if (i >= pointers.length)\n      pointers.push(new pointerPrototype());\n\n    pointers[i].id = touches[i].identifier;\n    pointers[i].down = true;\n    pointers[i].x = touches[i].pageX;\n    pointers[i].y = touches[i].pageY;\n    pointers[i].color = generateColor();\n  }\n});\n\nwindow.addEventListener('mouseup', () => {\n  pointers[0].down = false;\n});\n\nwindow.addEventListener('touchend', e => {\n  const touches = e.changedTouches;\n  for (let i = 0; i < touches.length; i++)\n    for (let j = 0; j < pointers.length; j++)\n      if (touches[i].identifier == pointers[j].id)\n        pointers[j].down = false;\n});\n\nwindow.addEventListener('keydown', e => {\n  if (e.code === 'KeyP')\n    config.PAUSED = !config.PAUSED;\n  if (e.key === ' ')\n    splatStack.push(parseInt(Math.random() * 20) + 5);\n});\n\nfunction generateColor () {\n  let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n  c.r *= 0.15;\n  c.g *= 0.15;\n  c.b *= 0.15;\n  return c;\n}\n\nfunction HSVtoRGB (h, s, v) {\n  let r, g, b, i, f, p, q, t;\n  i = Math.floor(h * 6);\n  f = h * 6 - i;\n  p = v * (1 - s);\n  q = v * (1 - f * s);\n  t = v * (1 - (1 - f) * s);\n\n  switch (i % 6) {\n    case 0: r = v, g = t, b = p; break;\n    case 1: r = q, g = v, b = p; break;\n    case 2: r = p, g = v, b = t; break;\n    case 3: r = p, g = q, b = v; break;\n    case 4: r = t, g = p, b = v; break;\n    case 5: r = v, g = p, b = q; break;\n  }\n\n  return {\n    r,\n    g,\n    b\n  };\n}\n\nfunction getResolution (resolution) {\n  let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n  if (aspectRatio < 1)\n    aspectRatio = 1.0 / aspectRatio;\n\n  let max = Math.round(resolution * aspectRatio);\n  let min = Math.round(resolution);\n\n  if (gl.drawingBufferWidth > gl.drawingBufferHeight)\n    return { width: max, height: min };\n  else\n    return { width: min, height: max };\n}\n\nfunction getTextureScale (texture, width, height) {\n  return {\n    x: width / texture.width,\n    y: height / texture.height\n  };\n}\n"],"mappings":"AAGA","sourceRoot":""}